import glob
import re
import os
import pandas as pd

# Set the prefix to activate the conda environment
shell.prefix("source $(conda info --base)/etc/profile.d/conda.sh && conda activate chip_frip_env && ")

###############
# Input
###############
chip_fastqs_path = config["input"]["ChIP_fastqs"]
if config["input"]["ChIP_input_table"] != '':
    chip_input_table = pd.read_table(config["input"]["ChIP_input_table"])

###############
# Parameters
###############
index = config["input"]["bowtie_index"]
process = config["common_params"]["processes"]
include_spikein = config["common_params"]["include_spikein"]
effective_genome_size = config["common_params"]["effective_genome_size"]
index_primary = config["spikein_params"]["index_primary"]
index_spikein = config["spikein_params"]["index_spikein"]
binsize = config["bamcoverage_params"]["binsize"]


quality = config["samtools_params"]["quality"]
distance = config["samtools_params"]["distance"]

if config["macs2_params"]["broad"]:
    broad_peaks_option = "--broad"
else:
    broad_peaks_option = ""

###############
# Output path
###############
chip_result_folder = config["output"]["ChIP_output_path"]

# Check if the directory exist. If not, create the directory
if not os.path.exists(chip_result_folder):
    os.makedirs(chip_result_folder)

########################
# Input validation
########################
if include_spikein:
    if index_spikein == "" or index_spikein == None:
        raise ValueError("if you include spikein procedure, then index_spikein need to be spcified")

if index_spikein != "" and index_spikein != None:
    if not include_spikein:
        raise ValueError("Since index_spikein is spcified, <include_spikein> parameter should be set to true")

########################
# Helper functions
########################
def get_chipseq_input_path(wildcards):
    row = chip_input_table[chip_input_table.ChIP == wildcards.sample_name]
    if row.empty:
        raise ValueError(f"Sample {wildcards.sample_name} not found in ChIP_input_table")
    
    input_sample_name = row['Input'].iloc[0]
    if pd.isna(input_sample_name):
        raise ValueError(f"No input sample specified for {wildcards.sample_name}")
    
    input_file = f"{wildcards.pathway_to_folder}/{input_sample_name}/{input_sample_name}.q{quality}.{wildcards.type}.bam" 
    
    return input_file

def get_chipseq_input_spikestats_path(wildcards):
    input_sample_name = chip_input_table[chip_input_table.ChIP == wildcards.sample_name]['Input'].iloc[0]  
    input_spikeinstats_file = f"{wildcards.pathway_to_folder}/{input_sample_name}/{input_sample_name}.spikein.stats"  
    
    return input_spikeinstats_file

def get_fastq_paths(wildcards):
    plain = f"{chip_fastqs_path}/{wildcards.sample_name}.fastq"
    gzipped = f"{chip_fastqs_path}/{wildcards.sample_name}.fastq.gz"
    paired1 = f"{chip_fastqs_path}/{wildcards.sample_name}_1.fastq"
    paired2 = f"{chip_fastqs_path}/{wildcards.sample_name}_2.fastq"

    if os.path.exists(plain):
        return plain
    elif os.path.exists(gzipped):
        return gzipped
    elif os.path.exists(paired2):
        return [paired1, paired2]

    raise FileNotFoundError(f"No input file found for sample {wildcards.sample_name}, here's the path{gzipped}, {wildcards.sample_name}")

def is_paired_end(sample_name):
    paired1 = f"{chip_fastqs_path}/{sample_name}_1.fastq"
    paired2 = f"{chip_fastqs_path}/{sample_name}_2.fastq"

    if os.path.exists(paired1) and os.path.exists(paired2):
        return True
    
    return False

#############################################
# Create lists of output filenames
#############################################
# q: would this be more readable in an if/else statement for paired/single end?
sample_filenames = glob.glob(chip_fastqs_path+'/*.fastq*')
fastq_filename_pattern = r"(_[12])?\.fastq.*"
samples = [re.sub(fastq_filename_pattern, '', s.split('/')[-1]) for s in sample_filenames]
samples = list(set(samples))
se_samples = [s for s in samples if not is_paired_end(s)]
pe_samples = [s for s in samples if is_paired_end(s)]

sam = expand(
        f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.sam",
        sample_name=samples
    )

bam_se = expand(
        f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.bam",
        sample_name=se_samples
    )
bam_pe = expand(
        f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.pairedend.q{quality}.bam",
        sample_name=pe_samples
    )

fixed_bam = expand(
        f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.bam",
        sample_name=pe_samples
    )

sort_bam = expand(
        f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.sort.bam",
        sample_name=samples
    )

dedup_bam = expand(
        f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.dedup.bam",
        sample_name=samples
    )

if include_spikein:
    spikein_stats_files = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.spikein.stats",
            sample_name=samples
        )

    primary_sort_bam = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort.bam",
            sample_name=samples
        )

    spikein_sort_bam = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_spikein}.sort.bam",
            sample_name=samples
        )
    if config["input"]["ChIP_input_table"] == '' :
        bw = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.{index_primary}.bw",
            sample_name=samples
        )
        bw_with_input = []

        peaks_bed = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort_peaks.narrowPeak",
            sample_name=samples
        )
        peaks_bed_with_input = []

    else:
        have_input = [s for s in samples if s in chip_input_table['ChIP'].unique()]
        no_input = [s for s in samples if s not in chip_input_table['ChIP'].unique()]
        bw = expand(
                f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.{index_primary}.rescale.bw",
                sample_name=have_input
            )
        bw_with_input = expand(
                f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.{index_primary}.bw",
                sample_name=no_input
            )
        peaks_bed = expand(
                f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort_peaks.narrowPeak",
                sample_name=no_input
            )
        peaks_bed_with_input = expand(
                f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort.withinput_peaks.narrowPeak",
                sample_name=have_input
            )
else:
    spikein_stats_files = []
    primary_sort_bam = []
    spikein_sort_bam = []
    bw_with_input = []
    index_primary = "no_primary"
    index_spikein = "no_spikein"
    bw = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.bw",
            sample_name=samples
        )
    if config["input"]["ChIP_input_table"] == '' :
        peaks_bed = expand(
            f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.dedup_peaks.narrowPeak",
            sample_name=samples
        )
        peaks_bed_with_input = []

    else:
        have_input = [s for s in samples if s in chip_input_table['ChIP'].unique()]
        no_input = [s for s in samples if s not in chip_input_table['ChIP'].unique()]
        peaks_bed = expand(
                f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.dedup_peaks.narrowPeak",
                sample_name=no_input
            )
        peaks_bed_with_input = expand(
                f"{chip_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.dedup.withinput_peaks.narrowPeak",
                sample_name=have_input
            )

rule all:
    input:
        sam,
        bam_se,
        bam_pe,
        fixed_bam,
        sort_bam,
        dedup_bam,
        spikein_stats_files,
        primary_sort_bam,
        spikein_sort_bam,
        bw,
        bw_with_input,
        peaks_bed,
        peaks_bed_with_input,

##############################
# Include rule modules
##############################
include: "rules/alignment.smk"
include: "rules/spikein.smk"
include: "rules/bigwig.smk"
include: "rules/peaks.smk"